# 10장 사용자에게 푸시 알림 보내기

## 푸시 알림의 생애

푸시 알림은 사시 하나로 이루어지지 않았습니다. 푸시알림은 사실 **Push API**를 사용하여 전송된 **메시지**와 **Notification API**를 사용하여 보여지는 **알림** 두가지 기능으로 이루어져 있습니다.



## Notification API

Notification API를 사용하면 웹페이지나 서비스워커가 시스템알림을 생성하고 표시할 수 있다. 사용자 알림을 표시하기 전에 우선 사용자에게 권한을 요철해야 합니다. 아래의 코드를 참고

```javascript
Notification.requestPermission().then(function(permission) {
  if (permission === "granted") {
    new Notification("Shiny");
  }
});
```

알림 표시 권한을 요청하는 것은 이 샘플 코드하나로 충분하다. 그리고 권한 부여가 된다면 Shiny라는 이름의 알람이 생성된다. 



## Push API

Push API를 사용하면 앱 사용자는 서버에서 보낸 푸시메시지를 구독하고 서버에서는 언제든지 브라우저로 메시지를 전송 할 수 있다. **푸시메시지는 서비스워커에 의해 제어**된다.  푸시메시지는 사용자기기에 언제든지 끊임없이 푸시를 보내 사용자를 괴롭히거나 서비스워커에서 사용자의 현재상태에 관한 데이터를 계속 전송하여 조용하게 사용자를 추적할 수 있습니다. 이런식으로 Push API가 남용되지 않도록 모든 푸시는 중앙 메시징 서버를 통해서 전달된다. 



## 푸시 알람의 간단한 과정 

이해하기 쉽도록 간단하게 4가지 과정으로 나누어 설명한다.

처음 두 단계는 **'푸시이벤트 구독하기'**와 **'서버에 구독 세부내용 저장하기'**이고 각각의 사용자는 이단계를 한 번씩 거치게된다.

마지막 두 단계는 **'서버에서 메시지 전달하기'**와 **'브라우저에서 작업하기'**입니다. 이 두 단계는 사용자에게 메시지를 전송할 때마다 발생합니다. 

먼저, 처음 두 단계는 웹페이지에서 Push API의 subscribe() 메소드를 호출합니다.  메소드가 호출되면 중앙메시징 **서버로 구독요청이 전달**되고 중앙서버는 신규 구독 상세정보를 페이지로 반환한다.  구독 상세 정보를 받은 페이지는 이 정보를 나중에 사용할 수 있도록 **앱 서버로 전송**한다.이때 구독 상세정보는 사용자 **상세정보를 저장**하는 테이블이나 객체저장소에 함께저장하는 겅우가 많습니다.

다음으로 마지막 두 단계는 메시지를 전송 할 때마다 필요한 두 단계로 우리의 앱서버는 이전에 저장해 두었던 **구독 세부 정보를 가져와서 메시징 서버로 메시지를 전송**할 떄 사용한다. 메시징 서버는 이 메시지를 받아 사**용자 브라우저로 전달**합니다.마지막으로 **사용자 브라우져에 등록된 서비스 워커는 메시지를 수신**하여 그 내용을 읽고 어떤 작업을 수행할지 결정합니다. 



## 푸시 알림 프로세스

사용자에게 푸시 알람을 전송하는 전체 프로세스를 확인해봅시다.

1. 페이지가 사용자에게 **알림을 보여주기 위한 권한을 요청**하면 사용자가 권한을 부여합니다.
2. 페이지가 **중앙 메시징 서버에 접속해 신규 구독 생성을 요청**합니다. 
3. **메시징 서버는 새로운 구독 세부 정보 객체를 응답**으로 반환합니다.
4. 페이지는 **우리의 앱 서버로 구독 세부 내용을 전달**합니다.
5. 우리의 앱 서버는 다음에 사용하기 위해 **구독 세부 정보**를 저장합니다.
6. 시간이 흘러 알림을 보낼 필요가 생겼습니다.
7. 우리의 앱 서버는 **저장했던 구독 세부 정보를 사용하여 사용자에게 보낼 메시지를 메시징 서버로 전송**합니다.
8. **메시징 서버는 사용자 브라우져로 메시지를 전달**합니다.
9. **서비스워커의 'push' 이벤트 리스너가 메시지를 수신**합니다.
10. **서비스워커가 메시지의 내용을 기반으로 알림을 표시**합니다. 



## 직접 알림 생성하기

이제 첫번째 알림을 만들어 봅시다.

### 알림을 윈한 권한 요청하기

우선 기본적으로 권한을 요청받아야한다. 현재 페이지가 권한을 가지고 있는지는 Notification.permission 속성값을 확인하면 알 수 있습니다.  또한 **Notification.requestPermission();**을 사용하여 권한을 요청하는 UI를 보여줄 수 있다. 

이때 Notification.requestPermission();는 사용자가 선택한 권한에 프로미스를 반환하는데 이 **프로미스는 resolve만 있다**. 즉 사용자가 권한을 수락하거나 거절하거나 그냥 창을 닫아버리는 상황에도 resolve가 된다.  그렇기 때문에 권한을 요청한 뒤에 혹은 알림을 생성하기 전에 현재의 권한 상태를 확인 해야합니다. 아래의 코드를 참고합니다

```javascript
Notification.requestPermission().then(function(permission) {
        if (permission === "granted") {
          console.log("이러면 권한이 있는 겁니다.");
          //알림을 보인다.
          showNotification();
        } else if (permission === "default") {
          console.log("사용자가 아무결정을 하지 않음");
        } else if (permission === "denied") {
          console.log("거절된 권한");
        }
});
```

* 사용자가 권한을 **승낙** & 알림 표시권한 **있음** : "granted"
  * requestPermission이 호출되었고 사용자가 이를 승인 했습니다 혹은 requestPermission이 호출되었지만 이전에 이미 권한을 부여받은 적이 있으므로 권한요청을 하지 않습니다.
* 사용자가 아직 **결정하지 않음** & 알림 표시권한 **없음** : "default"
  * 현재 페이지에는 알림을 표시항 권한이 없습니다. requestPermission가 호출되었지만 사용자는 아무런 결정을 하지 않고 창을 닫아 버렸습니다.
* 사용자가 권한을 **거부** & 알림 표시권한 **없음** : "denied"
  * requestPermission이 호출되었지만 사용자는 권한을 거절했습니다. 혹은 requestPermission가 호출되었지만 이전에 이미 권한을 거절한 적이 있으므로 권한 요청을 할 수 없습니다.



### 알림 표시하기

이제 새로운 알림을 생성해봅시다. 새로운 Notification객체를 생성하면 됩니다. 아래의 코드를 참고합시다.

```javascript
Notification.requestPermission().then(function(permission) {
    if (permission === "granted") {
        console.log("이러면 권한이 있는 겁니다.");
          //알림을 생성한다.
        new Notification("알람!");
    }
});
```

권한을 요청한 뒤에 알람! 이라는 알람이 생길것입니다! 

하지만....이 코드는 모바일에서는 작동하지 않고 **데스크탑에서 만** 잘 작동하는 모습을 보여줍니다ㅠㅠ 이것을 이해하기 위해서는 모바일에서 알람이 어떻게 작동되는지 알아야합니다! 

페이지가 알림을 생성하면 알림은 브라우저 밖(운영체제 레벨)에서 렌더링됩니다. 시용자가 사이트를 떠난지 한참이 지나도 이 알람은 표시될 것이고 사용자는 이 알람과 **상호 작용**할 수 있습니다. 알림과 상호작용을 할 수 있으려면 알림이 상위레벨 즉, 서비스워커에 위치해야합니다.

데스크톱과 모바일에서 모두 작동가능한 알림을 설정하려면 **서비스워커를 통해 알림을 생성**해야 합니다. 이때 우리는 서비스워커의 코드를 직접 수정하지 않아도 페이지에서 **서비스워커의 registration객체에서 showNotification()을 호출**할 수 있다. 아래의 코드를 참고하자.

```javascript
Notification.requestPermission().then(function(permission) {
    if (permission === "granted") {
           navigator.serviceWorker.ready.then(function(registration) {
              registration.showNotification("알림입니다");
       });
        }
});
```

#### 이제 알림을 좀더 멋지게 꾸며볼까요?

아래의 코드와 주석을 읽어보자

```javascript
Notification.requestPermission().then(function(permission) {
  if (permission === "granted") {
    navigator.serviceWorker.ready.then(function(registration) {
      registration.showNotification("멋진 알림!!!", {
        //알림내 텍스트 본문
        body: "PWA 알림은 멋지다",
        //알림의 포시될 이미지 URL
        icon: "/img/reservation-gih.jpg",
        //알림을 보낸 앱을 상징하는 뱃지 혹은 알림의 종류에 따라 성절하기도 함
        badge: "/img/icon-hotel.png",
        //알림을 나타내는 고유 식별자이다. 만약 지금 표시된 알림과 같은 태그를 사용한다면 예전 알림은 조용히 새 알림으로 대체됩니다!
        tag: "멋진 알림",
        //알림에 액션 객체를 이용하여 최대 2개의 버튼을 추가 할 수 있고 이것으로 알림에서 바로 작업을 할 수 있다. (나중에 더 자세히)
        actions: [
          {
            action: "confirm1",
            title: "맞아!",
            icon: "/img/icon-confirm.png"
          },
          {
            action: "confirm2",
            title: "아니야!",
            icon: "/img/icon-cal.png"
          }
        ],
        //진동이다.배열의 값은 진동시간, 정지시간을 의미한다.
        // 500ms 진동 -> 110ms 정지 -> 500ms 진동 .......
          //근데 왜 내폰에서는 기본 진동만울리지... 지우면 안나지만 배열의 인자가 하나도없지만 진동은 기본진동이 울리넹
        vibrate: [
          500,
          110,
          500,
          110,
          450,
          110,
          200,
          110,
          170,
          40,
          450,
          110,
          200,
          110,
          170,
          40,
          500
        ]
      });
    });
  }
});
```

아직 우리는 Notification을 배웠습니다. 사용자가 홈페이지에 머무르지 않을때도 알림을 보내고 싶습니다.

우리의 호텔앱을 발전시키면서 푸시알림을 구현 해봅시다.



## 우리의 호텔 앱에 푸시 이벤트 추가하기

호텔앱에 알림기능 지원을 위해 우리의 앱을 발전 시켜봅시다.

### 권한 요청 및 알림생성하기

먼저 사용자의 권한을 요청받은 뒤 권한을 받으면 앞으로 예액과 관련된 변경사항을 알림형태로 받을 수 있다고 안내하는 알림을 표시할것입니다.

아래의 코드를 my-account.js의 addReservation()함수 바로 위에 추가합시다.

```javascript
var showNewReservationNotification = function() {
  navigator.serviceWorker.ready.then(function(registration) {
    registration.showNotification("예약 받음!", {
      body:
        "예약해주셔서 감사합니다!\n" + "예약이 변경되면 알림을 드리겠습니다.",
      icon: "/img/reservation-gih.jpg",
      badge: "/img/icon-hotel.png",
      tag: "new-reservation"
    });
  });
};

var offerNotification = function() {
  if ("Notification" in window && "serviceWorker" in navigator) {
    Notification.requestPermission().then(function(permission) {
      if (permission === "granted") {
        showNewReservationNotification();
      }
    });
  }
};
```



* showNewReservationNotification()
  * 사용자가 신규 예약을 할 때 새 알림을 표시 합니다.
  * 사용자가 이미 앱 알림 권한을 부여했다고 가정합니다.
* offerNotification()
  * 현재 브라우저에서 서비스워커와 Notification이 지원하는지 확인 한 뒤 알림을 위한 권한을 요청
  * 권한이 요청되면 showNewReservationNotification()를 호출하여 알림을 보냄



다음으로 새로만든 우리의 함수를 호출해야합니다. 새로운 예약이 발생할때 알림이 가는 것이니까 my-account.js에 addReservation함수에 한줄을 추가해 봅시다.

```javascript
var addReservation = function(id, arrivalDate, nights, guests) {
  var reservationDetails = {
    id: id,
    arrivalDate: arrivalDate,
    nights: nights,
    guests: guests,
    status: "Sending"
  };
  addToObjectStore("reservations", reservationDetails);
  renderReservation(reservationDetails);
  if ("serviceWorker" in navigator && "SyncManager" in window) {
    navigator.serviceWorker.ready.then(function(registration) {
      registration.sync.register("sync-reservations");
    });
  } else {
    $.getJSON("/make-reservation", reservationDetails, function(data) {
      updateReservationDisplay(data);
    });
  }
  //이줄을 추가했다.
  offerNotification();
};
```



### 푸시 이벤트 구독하기

이제 우리는 알림을 보낼 수 있습니다!!! 하지만 더 발전 하기 위해서는 사용자가 접속하지 않았으 때도 알림을 받을 수 있어야 합니다. 그렇기 위해서 우리는 **Push API**를 알아야 합니다

1. 메시징 서버에 접속하여 이 사용자에 대한 새로운 구독정보를 요청합니다.
2. 메시징 서버는 해당 사용자에 대한 새로운 구독정보를 저장하고 상세 구독 정보를 돌려줍니다. 
3. 다음번 사용자에게 메시지를 보낼 때 사용할 수 있도록 전달 받은 상세 구독정보를 앱 서버에 저장합니다.

**하지만..!**

우리가 구독을 생성하고 저장하는 과정을 시작하기 전에 **암호화**를 짚고 넘어가야합니다!

서버상에 구독 상세정보에 접근 할 수 있는 누군가가 사용자가 구독중일때 상세정보를 가져갈 수 있는 악의적인 스크립트 혹은 애드온으로 사용자에게 악의적으로 사용할 수 있습니다. 

즉 , 우리의 서버에서만 푸시를 보내기 위해서 개발자의 앱서버에 저장된 **비공개 키**로 서명된 메시지만 사용자에게 전달합니다.  메시지가 올바른 키로 서명되었는지 확인하기 위해서 **각 비공개키에 대응되는 공개 키**를 가지고 있습니다. 이 키는 우리의 앱서버에서 메시징서버로 전송된 메시지가 올바른 비공개키로 서명되었는지 확인할 대만 사용합니다.

비공개키는 우리의 앱서버에만 가지고 있는 권한입니다. 메시징 서버에게 우리가 메시지를 보냈다는 것을 증명 할 수 있는 수단인것 입니다.

정리하면 

1. 앱을 만들 때, 공개 키와 비공개 키를 생성합니다.
2. 비공개키는 비밀로 유지 되고 서버를 절대 떠나지 않습니다.
3. 공개키는 스크립트에 포함되어 있고 구독을 생성할 때 메시징 서버로 전송됩니다. 
4. 메시징 서버는 나머지 구독 세부 정보와 함께 공개키를 저장합니다.
5. 서버가 메시지를 보내고자 할 때 비공개키를 사용하여 서명한 후에 메시징 서버로 전송합니다.
6. 메시징 서버는 공개 키를 사용해 메시지가 올바른 공개키로 서명되어 있는지 확인하여 비공개키로 서명되어 있으면 메시지를 보낸다.



### 공개 VAPID 키 , 비공개 VAPID 키 생성하기

푸시메시지를 서명하고 메시지를 확인하는 데사용되는 키를 **VAPID(Voluntary Application Server Identification for Web Push: 웹 푸시를 위한 자발적 어플리케이션 서버 식별)**라고 합니다.

이것을 사용하기 위해 우리는 web-push 라이브러리를 사용할 계획입니다. 

먼저 web-push 라이브러리를 설치합시다 `npm install web-push --save-dev` 를 입력 한 뒤 프로젝트 루트에 generate-key.js라는 이름의 파일을 생성하고  아래의 코드를 작성합니다.

```javascript
var webpush = require("web-push");
console.log(webpush.generateVAPIDKeys());
```

그리고  터미널 창에 `node generate-key.js`로 실행 시켜봅니다.! 그렇다면 아래와 같이 공개키와 비공개키가 보일것입니다.!!

```javascript
//$ node generate-key.js
{
  publicKey: 'BGHl0PzjfQXpiyJHqnex4-JjaK5pvCxoH6S6wbEkNA7ep7WI-jXLo-IIjecKzeCVv8',
  privateKey: 'ezJPOsxgbtrDdpsWGd52tm1H84M3wMq7Hy6K2W4t3_g'
}
```

이 키는 안전한 곳에 저장해둬야 합니다. 우리는 이것을 통해서 이 명령어가 샐행되면 새로운 키 쌍이 생성된다는 점을 알아 냈습니다. 

우리의 호텔앱에서는 server의 디렉토리에서 push-key.js파일에 비공개 키와 공개키를 모두 저장하겠습니다. 그후 .gitignore에도 추가하여 코드를 커밋할 때는 올라가지 않도록 하겠습니다. 

우리의 코드에서 server디렉토리의 generate-push-key.js를 보면 실행되었을때 새로운 push-key.js파일이 생성되어 그 안에 키가 저장됩니다. 이제 우리가 위에서 만든  generate-key.js를 지우고 generate-push-key.js를 실행 시켜봅시다.

`node server/generate-push-key.js`

생성되었다는 콘솔 문구와 새로운 파일이 생겼다.



### GCM 생성하기

안타깝게도 우리는 VAPID만으로는 모든 브라우저에 푸시를 보낼 수 없습니다. 우리는 GCM API키를 생성하여 이전 버전의 브라우저에서도 푸시알림이 작동하게 할 수 있다. 

**파이어베이스 클라우드 메시징**인터페이스 를 이용하여 **GCM API(FCM API)**를 받을 수 있다

1.  [파이어베이스](https://firebase.google.com/?hl=ko)에 접속하여 구글 계정으로 로그인 합니다.
2. 새 프로젝트를 생성합니다.
3. 프로젝트 페이지에서 톱니바퀴모양의 설정 버튼을 눌러 프로젝트 설정으로 들어갑니다.
4. 프로젝트 설정에서 클라우드 메시징을 선택합니다.
5. 프로젝트 사용자 인증 정보가 표시되고 서버키와 발신자 ID가 표시됩니다. 
6. push-key.js의 파일을 열고 GCMAPIKey의 값을 방금 생성한 서버키로 설정합니다.  내용은 아래와 같습니다.

```javascript
{
  GCMAPIKey:
    "AAAAOf2JWFQ:APA91bFHdFmsRuEvky4a-8z1UVydnkj-ikoWe_3caP7YM3k5pH03HeSR4M0QtMg0I-0",
  subject: "mailto:your@email.com",    
  publicKey: 'BGHl0PzjfQXpiyJHqnex4-JjaK5pvCxoH6S6wbEkNA7ep7WI-jXLo-IIjecKzeCVv8',
  privateKey: 'ezJPOsxgbtrDdpsWGd52tm1H84M3wMq7Hy6K2W4t3_g'
}
```

이제 새로운 구독을 생성하기 위해 클라이언트에 GCM 발신자 ID를 추가합시다. public디렉토리에서 manifest,json파일을 열어 gcm_sender_id를 추가해줍니다. 아래의 코드를 참고

```json
{
  "short_name": "Gotham Imperial",
  "name": "Gotham Imperial Hotel",
  "description": "Book your next stay, manage your reservations, and explore Gotham",
  "start_url": "/my-account?utm_source=pwa",
  "scope": "/",
  "display": "fullscreen",
  "icons": [
    {
      "src": "/img/app-icon-192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "/img/app-icon-512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "theme_color": "#242424",
  "background_color": "#242424",
   //이곳 추가
  "gcm_sender_id": "249066772564"
}
```

자 이제 준비는 끝났습니다. 계속 코딩해 봅시다.



### 새로운 구독 생성의 원리 및 구조

우리는 **ServiceWorkerRegistration** 객체를 이용하여 **PushManager interface**를 받아 올 수 있습니다. 이 인터페이스는 



