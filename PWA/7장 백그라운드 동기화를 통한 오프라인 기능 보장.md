# 백그라운드 동기화를 통한 오프라인 기능 보장

**백그라운드 동기화를 사용하면 인터넷 연결 상태와 상관없이 사용자가 수행하는 모든 작업이 완료되었는지 확인 이가능하다.**



## 백그라운드 동기화는 어떻게 작용하는가??

백그라운드 동기화의 본질은 페이지 context에서 이루어지는 작업을 백그라운드로 옮기는 작업이다.

백그라운드에서 작업을 처리하면 쉽게 휘발되는 개별 웹페이지의 특성에 벗어날 수 있다. 언제든 닫힐 수 있고, 사용자의 네트워크는 끊어질 수 있으며 때로는 서버가 다운될 수 있다. 하지만 사용자 기기에 브라우저가 설치되어 있는 한 백그라운드 동기화작업은 성공적으로 완료될 떄 까지 사라지지 않습니다.

따라서 **모든 페이지가 닫혀도 계속 진행되어야 하는 모든 작업에 백그라운드 동기화사용을 고려** 해 볼 수 있다. 



## 백그라운드 동기화의 간략한 사용법

페이지에서 Ajax호출과 같은 작업을 수행하는대신 동기화 이벤트를 등록하면된다.

```javascript
navigator.serviceWorker.ready.then(function(registration){
    registration.sync.register("send-messages");
});
```

위의 코드는 웹페이지에서 실행될 수 있다. 활성화된 서비스워커의 등록객체를 받아와서 "send-messages"라는 동기화 이벤트를 등록한다.

이제 서비스워커에 동기화 이벤트를 수신할 "sync" 이벤트 리스너를 추가하자

```javascript
self.addEventLsitener("sync",function(event){
    if(event.tag === "send-messages"){
        event.waitUntil(function(){
            var sent = sendMessages();
            if(sent){
                return Promise.resolve();
            }
            else {
                return Promise.reject();
            }
        });
    }
});
```

sync이벤트 리스너에서 waitUntil을 사용해 이벤트 종료 요청전까지 이벤트가 유지되도록 처리하는 부분에 주목하자.  

이렇게 함으로써 필요한 작업을 시도하고 실행할 수 있는 시간을 벌 수 있고 처리 결과에 따라 이벤트를 성공적으로 리졸브하거나 아니면 리젝할 수 있다. sync 이벤트 리스너에서 리젝된 프로미스를 반환하면 브라우저는 해당 동기화 작업을 큐에 쌓아 다음번에 다시 시도 될 것이다. 

즉 "send-messages"라는 sync이벤트는 사용자가 앱을 종료한 후에도 성공할때 까지 다시 시도 될 것이다. 





## The SyncManager

동기화 이벤트 관련된 모든 상호작용은 Sync Manager를 통해서 이루어진다.  Sync Manager는 동기화 이벤트를 등록하고 현재 등록된 동기화 작업을 가져오는 기능을 제공하는 서비스워커 인터페이스이다.

### Sync Manager접근하기

활성화된 서비스 워커 등록객체로 부터 Sync Manager에 접근할 수 있습니다. 등록객체를 가져오는 방법은 서비스워커에서 가져오는지 아니면 페이지에서 가져오는지에 따라 조금씩 달라진다. 



서비스워커에서는 **글로벌객체를 통해 쉽게 서비스워커 등록 객체에 접근이 가능**하다. 

```javascript
self.registration
```



서비스워커가 관리하는 페이지의 경우에는 navigator.serviceWorker.ready을 호출하여 현재 활성화된 서비스워커 등록 객체에 접근할 수 있다. 함수호출후에 성공적으로 resolve될때 서비스워커 등록객체를 반환하는 프로미스가 반환된다.

```javascript
navigator.serviceWorker.ready.then(function(registration){});
```



### 이벤트 등록하기 

동기화 이벤트를 등록하려면 SyncManager에서 등록하고자하는 **동기화 이벤트의 이름을 파라미터로 register함수를 호출**합니다. 예를들어 이름이 "send-messages"인 이벤트를 등록하려면 아래와 같다,

```javascript
registration.sync.register("send-messages");
```

서비스워커가 제어하는 페이지에 같은 이벤트를 등록하려면 아래와 같은 코드를 사용하면된다.

```javascript
navigator.serviceWorker.ready.then(function(registration){
    registration.sync.register("send-messages");
});
```



### 동기화 이벤트 (동기화 이벤트를 등록하면 어떤 일이 일어날까?)

SyncManager는 간단한 동기화 이벤트 태그 목록을 유지한다. 이 목록에는 각각의 이벤트가 어떤 이벤트인지, 무엇을 하는지에 대한 로직은 포함되어 있지 않습니다. 구현은 전적으로 서비스 워커의 sync이벤트 리스너 코드에게 달려있습니다.  **SyncManager가 알고 있는 것은 어떤 이벤트가 등록되었는지, 언제 호출되었는지, 어떻게 동기화이벤트를 전달할지**에 대한 것들이다. 

#### SyncManager가 sync이벤트를 발생시키는 3가지 상황

1. 동기화 이벤트 등록직후
2. 사용자 상태가 오프라인에서 온라인으로 변경될 때
3. 성공적으로 완료되지 않은 동기화 이벤트가 있을 경우, 매 분마다 



서비스워커는 발송된 동기화 이벤트를 프로미스 형식으로 수신하고 처리할 수 있다. 

* 프로미스가 resolve 되면 
  * SyncManager에서 해당 동기화 이벤트가 삭제된다. 
* 프로미스가 reject되면 
  * 다음 번 동기화 시점에 다시 시도될 수 있도록 SyncManager에 남게 된다.



### 이벤트 태그(이벤트 이름)

이벤트 태그는 **유일**해야한다. SyncManager에서는 이미 존재하는 태그명으로 sync이벤트를 등록하면 SyncManager는 이를 **무시하고 중복으로 추가하지 않는다.**  이부분은 SyncManager의 가장 **유용한 특징**인 부분이다. **믾은 수의 비슷한 작업을 하나의 이벤트로 그룹화하여 처리하도록 도와준다.** 새로운 작업이 추가될 때마다 이벤트가 이미 등록되어 있는지 혹은 현재 실행되고 있는지 확인하지 않고 모든작업을 처리하는 동기화 이벤트를 추가 할 수 있다.



### 등록된 동기화 이벤트 목록 가져오기

SyncManager의 **getTags()** 메소드를 사용하면 실행 예정인 전체 동기화 이벤트 목록을 받아 올 수 있습니다. 

getTags는 프로미스를 반환한다 프로미스가 resolve되면 **동기화 이벤트 태그 이름이 채워진 배열**을 가져 올 수 있다. 

"hello-sync"라는 이름의 동기화 이벤트를 등록하는 예제를 살펴봅시다. 이벤트가 등록되면 모든 이벤트 목록이 콘솔에 출력된다.

```javascript
self.registration.sync
    .register("hellow-sync")
    .then(function() {
        return self.registration.sync.getTags();
    })
    .then(function(tags) {
        console.log(tags);
    });
```

서비스워커내에서 해당 코드를 실행하면 ["hellow-sync"]가 출력된다.

서비스 워커가 제어하는 체이지에서는 위에서 했던 **ready**를 사용해 등록 객체를 먼저 받아오는 방법을 사용하여 비슷한 결과를 얻을 수 있다.

```javascript
navigator.serviceWorker.ready.then(function(reservation) {
    registration.sync
        .register("send-message")
        .then(function() {
            return registration.sync.getTags();
        })
        .then(function(tags) {
            console.log(tags);
        });
});

```

위 코드를 실행하면 ["send-messages"]가 나와야 정상이지만 나는 

Uncaught TypeError: Cannot read property 'ready' of undefined at serviceworker.js:148

위와 같은 오류가 난다. ready 가 없다는 오류가 없다는 말과 출력되지 않는다. 다음에 자세히 알아보기로 ㅅㅂ



### 마지막 기회

가끔 SyncManager가 특정 sync이벤트가 계속 실패한다고 판단하고 자원낭비를 막기위해 이벤트를 제거하기전 **마지막으오 한번더 sync이벤트를 보내기로 결정**할 수 도 있다. 이런 경우 전달된 sync 이벤트의 **lastChance속성**을 확인해 해당 이벤트가 SyncManager가 마지막으로 보낸 이벤트라는 것을 감지하고 필요한 작업을 수행할 수 있다.

```javascript
self.addEventListener("sync",event => {
    if (event.tag == "add-reservation"){
        event.waitUntil(
            addReservation()
            .then(function(){
                return Promise.resolve();
            }).catch(function(error){
                if(event.lastChance){
                    return removeReservation();
                }
                else{
                    return Promise.reject();
                }
            })
        );
    }
});
```

기존 웹앱에서 동기화를 구현하는 것은 그렇게 간단한 작업이 아니다 이제 프로젝트에서 동기화를 어떻게 다루고 어떻게 구현할지 배워보자 



## 동기화 이벤트로 데이터 넘기기

