# 6장 IndexDB로 로컬에 데이터 저장하기



## IndexDB란?

--> **브라우저 내에서 제공된 트렌잭션 객체 저장소 데이터베이스**



* IndexDB는 트랜잭션 기반으로 작동한다. 
* IndexDB는 객체 저장소 데이터베이스다
  * 기존에 내가 알던 **테이블 기반의 관계형 데이터베이스**가 아닌 객체를 저장하는 **객체형 데이터베이스**
  * 객체는 JS객체, 숫자, Boolean등등 JS가 처리할 수 있는 대부분의 데이터포멧들이다
* IndexDB는 인덱스된 데이터베이스이다
* IndexDB는 브라우저 기반이다.
  * 해당 내용들은 차차 자세히 알아가겠다





## IndexDB 실습해보기

### IndexDB 커넥션 열기

아래의 코드를 indexed.html에 추가해보자

```javascript
//데이터베이스 커넥션을 열기위한 IDBrequest객체를 반환
var request = window.indexedDB.open("my-db",1);
//해당 요청의 2가지 이벤트 수신가능
//실패(error)이벤트 
request.onerror = function(event){
    console.log("DB-ERROR : " , event.target.error);
};
//성공(success)이벤트
request.onsuccess = function(event){
    var db = event.target.result;
    console.log("DB-SUCCESS : ", db);
    console.log("저장된 내용 : ",db.dbjectStoreName);
};
```

 이 코드를 실행 시키면 바로 브라우저에서 my-db라는 이름의 데이터베이스가 생성되고 열린다. 이후 success이벤트가 발생하면 해당 데이터베이스에 포함된 객체저장소 목록을 콘솔에 기록합니다.



### 데이터베이스 버전 번호 관리 / 객체 저장소 변경

```javascript
var request = window.indexedDB.open("my-db",1);
```

위 코드에서 두번째 인자 숫자 1이 IndexDB의 버전이다. IndexDB또한 서비스워커 처럼 버전을 가지고 있다.

객체 저장소 추가/변경/삭제과 같이 데이터베이스의 **구조를 변경할 때마다 새로운 버전을 생성**해야한다. 버전번호를 증가시킴으로 새 데이터베이스 버전을 만들 수 있고 브라우저가 기존 버전의 숫자보다 높은 숫자의 버전을 감지하면 **upgrade needed이벤트**가 발생하여 데이터 베이스를 업데이트한다.

 upgrade needed이벤트를 위해 아래의 코드를 추가하자

```javascript
request.onupgradeneeded = function(event){
    var db = event.target.result;
    db.createObjectStore("customers",{
        keyPath: "passport_number"
    });
};
```

업데이트 이벤트에서 데이터베이스 객체를 가져오고 customer라는 새로운 객체 저장소를 생성합니다. 또한 여궈번호(passport_number)를 각 객체의 고유키로 정의하기위해 keyPath를 사용합니다.

이제 버전은 2로 올리면 바뀐 모습을 볼 수 있다.



### 객체 저장소에 데이터 추가하기

객체 저장소를 사용하기 위해 객체가 저장되어야 한다. 몇몇 사용자를 추가해보자

```javascript
request.onsuccess = function(event) {
    var db = event.target.result;
    var customerDate = [{
        "passport_number" : "6651",
        "first_name" : "Kim",
        "last_name" : "Sungheyon"
    },{
        "passport_number" : "7727",
        "first_name" : "Moon",
        "last_name" : "Jungmin"
    }];
    var customerTransaction = db.transaction("customers","readwrite");
    customerTransaction.onerror = function(event){
        console.log("ERROR : ",event.target.error);
    };
    //objectStore로 customers를 열고 반복문과 .add를 이용하여 값들을 넣어준다.
    var customerStore = customerTransaction.objectStore("customers");
    for(var i = 0; i <customerDate.length;i++){
        customerStore.add(customerDate[i]);
    }
};
```

이 코드는 새로운 readwrtie 코드를 생성하고 해당 작업의 범위를 customers객체 저장소로 지정한다. 또한 에럭 발생하면 해당 에러를 콘솔에 작성한다. 



### 객체 저장소에서 데이터 읽기(추가한 객체 가져오기)

데이터를 읽는 것에는 3가지 방법이 있다

1.  키를 사용하여 단일 객체를 요청
2. 커서를 사용하여 저장소의 모든 객체를 순회
3. 인덱스를 사용하여 더 작은 데이터 그룹으로 검색



### 특정 키를 이용하여 객체 저장소의 단일 객체를 읽기

```javascript
request.onsuccess = function(event) {
    var db = event.target.result;
    var customerTransaction = db.transaction("customers");
    var customerStore = customerTransaction.objectStore("customers");
    var reqeust = customerStore.get("7727");
    request.onsuccess = function(event){
        var customer = event.target.result;
        console.log("First name : ", customer.first_name);
        console.log("last name : ", customer.last_name);
    };
};
```

#### TIP 대부분의 indexDB의 메소드를 연결하면 더 짧고 간결한 코드를 만들수 있다.

아래의 코드는 위에 코드와 동일하게 작동한다. 아래의 방법을 사용하도록하자

```javascript
request.onsuccess = function(event) {
    event.target.result
    .transaction("customers")
    .objectStore("customers")
    .get("7727")
    .onsuccess = function(event){
        var customer = event.target.result;
        console.log("First name : ", customer.first_name);
        console.log("last name : ", customer.last_name);
    };
};
```



### IndexDB 버전관리

DB의 버전을 그냥 올려버리면 에러가 생길것이다.

**Failed to execute 'createObjectStore' on 'IDBDatabase': An object store with the specified name already exists**

그리고 데이터베이스 에러 핸들러에서는 아래와 같은 오류를 보여준다.

**DOMException: Version change transaction was aborted in upgradeneeded event handler.**

아래의 코드를 추가하고 버전2가 되었다. 버전이 올라간것을 인지하여 아래의 코드(upgrade needed)가 실행됐다. 즉 버전 2에서 customer를 생성했고 이때 임의로 버전 3으로 올리게 된다면 역시 브라우저는 버전이 올라간 것을 인지하여 아래의 코드를 또 실행 시킨다. 

```javascript
request.onupgradeneeded = function(event) {
    var db = event.target.result;
    db.createObjectStore('customers', {
        keyPath: 'passport_number'
    });
};
```

위의 코드를 또 실행하면 이미존재하는 customer를 다시 생성하는 격이니 오류가 생기는 것이다.



사용자마다 버전이 다를 수 있으므로 재방문혹은 처음 방문시에 데이터베이스를 최신 버전으로 만들어줄 필요성이 있다.

이때우리는 **마이그레이션**을 사용합니다

아래의 코드는 변경전에 변경이 필요한지 항상 확인 할 수 있고 존재하지 않는 저장소만 추가 할 수 있다. 이미 존재하는 인덱스의 경우에만 인덱스를 삭제할 수 있다.

```javascript
request.onupgradeneeded = function(event) {
    var db = event.target.result;
    if (!db.objectStoreNames.contains("customers")){
        db.createObjectStore('customers', {
            keyPath: 'passport_number'
        });
    };
};
```



### 커서를 이용하여 객체 읽기

정확한 키 정보를 알아야하고 단일의 객체만을 찾아주는 get말고 이번에는 어려 개체를 검색해보자

커서는 SQL에서 SELECT * FROM table 같이 모든 것을 보여주지만 커서에는 결과값을 포함하고 있지 않다. 

커서는 객체 저장소에 존재하는 하나의 레코드를 가리키고 continue 혹은 advance를 통해서만 다음으로 넘어간다. 이렇게하면 메모리가 없어도 용량이 큰 객체 저장소를 순회하거나 통과 할 수 있다. 

```javascript
request.onsuccess = function(event) {
    var db = event.target.result;
    var customerTransaction = db.transaction("customers");
    var customerStore = customerTransaction.objectStore("customers");
    var customerCursor = customerStore.openCursor();
    customerCursor.onsuccess = function(event){
        var cursor = event.target.result;
        if (!cursor){
            return ;
        }
        console.log(cursor.value.first_name );
        cursor.continue();
    };
};
```

마지막 데이터를 전달하거나 객체 저장소가 비었더라도 커서는 앞으로 이동할 떄마다 onsuccess이벤트를 방생시킨다 이때 커서는 null을 가리키고 있기때문에 이것을 처리해 줘야한다. if문이 있는 코드를 작성하지 않으면 오류가 뜬다.



### 인덱스 생성하기

인덱스를 사용하면 쿼리를 사용할 수 있고 쿼리와 매칭되는 것들만 보여주는 커서를 열 수 있다

이것을 실습하기 위해 새로운 저장소를 생성할 것입니다. 이것은 각각의 화폐에 환율을 저장합니다.

```javascript
{"exchange_from" : CAD , "exchange_to" : "USD", "rate" : 0.77}
```

데이터 베이스 버전을 하나 올리고 onupgradeneeded메소드를 아래와 같이 수정

```javascript
request.onupgradeneeded = function(event) {
    var db = event.target.result;
    if (!db.objectStoreNames.contains("customers")){
        db.createObjectStore('customers', {
            keyPath: 'passport_number'
        });
    };
    if(!db.objectStoreNames.contains("exchange_rates")){
        var exchangeStore = db.createObjectStore("exchange_rates",{
            autoIncrement : true
        });
        exchangeStore.createIndex("from_idx", "exchange_from",{
            unique : false
        });
        exchangeStore.createIndex("to_idx", "exchange_to",{
            unique : false
        });
        exchangeStore.transaction.oncomplete = function(event){
            var exchangeRates = [
                {
                    "exchange_from" : "CAD",
                    "exchange_to" : "USD",
                    "rate" : 0.77
                },
                {
                    "exchange_from" : "JPY",
                    "exchange_to" : "USD",
                    "rate" : 0.009
                },
                {
                    "exchange_from" : "USD",
                    "exchange_to" : "CAD",
                    "rate" : 1.29
                },
                {
                    "exchange_from" : "CAD",
                    "exchange_to" : "JPY",
                    "rate" : 81.60
                },
            ];
            var exchangeStore = db.transaction("exchange_rates", "readwrite").objectStore("exchange_rates");
            for (var i = 0; i<exchangeRates.length; i++){
                exchangeStore.add(exchangeRates[i]);
            }
        };
    }
};
```



버전이 올라가면 실행되는 코드에서 먼저 customer와 exchange_rates가 각각 있는지 확인하여 없는 사용자만 데이터를 받는다. exchange_rates에서 **autoIncrement : true는 자동 증가키**이다. 따로 기본키가 없을때 생성해주는 키이다. 이러한 키를 **아웃오브라인 키**라고 하고 이전의 예시처럼 keyPath가 있는 것은 **인라인 키**라고 한다. 그다음 새로운 인덱스 2개를 생성한다.



### 인덱스를 이용하여 데이터 읽기

인덱스를 이용하여 특정 기준과 일치하는 결과만을 순회하는 커서를 생성 할 수 있다.  아래의 코드는CAD에서 다른 모든 화폐에 대한 환률을 기록한다.

```javascript
request.onsuccess = function(event) {
    var db = event.target.result;
    var exchangeTransaction = db.transaction("exchange_rates");
    var exchangeStore = exchangeTransaction.objectStore("exchange_rates");
    var exchangeIndex = exchangeStore.index("from_idx");
    var exchangeCursor = exchangeIndex.openCursor("CAD");
    exchangeCursor.onsuccess = function(event){
        var cursor = event.target.result;
        if (!cursor){
            return ;
        }
        var rate = cursor.value;
        console.log(rate.exchange_from + " to " + rate.exchange_to +" : "+ rate.rate);
        cursor.continue();
    };
};
```

설명 마저적기