# 서비스워커 생명주기와 캐시관리

지금까지 실습하면서 Update on reload 모드를 이용했지만 이것은 바람직하지 않다.  이번 챕터에서 서비스워커의 생명주기를 정확하게 이해하고 넘어 가자



## 서비스 워커의 생명주기

![서비스워커 생명주기](..\참고자료\서비스워커 생명주기.jpg)

* 설치 중

  * navigator.serviceWorker.register를 이용하여 사로운 서비스 워커를 등록할때 자바스크립트가 다운로드되고 파싱이 되면 **설치중**상태로 들어간다. 
  * 설치가 성공적으로 끝나면 **설치됨**상태가 된다
  * 설치중에 에러가 발생하면 페이지를 새로고침하여 다시 등록하거나 아니면 스크립트 **중복(Redundant)**상태의 구렁으로 영원히빠져 버린다.

* 설치 됨/ 대기 중

  * 서비스워커가 성공적으로 설치되면, **설치 됨**상태로 넘어간다. 

  * 이후 다른 서비스워커의 유무에 따라 상태가 달라진다.

  * |      다른 서비스워커 유무       |     상태      |
    | :-----------------------------: | :-----------: |
    |    다른 서비스워커가 제어 중    |  **대기 중**  |
    | 다른 서비스워커가 제어하지 않음 | **활성화 중** |

* 활성화 중 
  * 서비스워커가 활성화되어 앱을 제어하기 전에 **activate** 이벤트가 발생한다. 
  * install 과 비슷하게 waitUntil이 사용가능하다. 
* 활성화 됨
  * 서비스워커가 활성화되면 페이지를 제어하고 fetch 이벤트와같은 동작으러 받을 준비가 됐습니다.
  * 서비스워커는 로딩이 시작하기 전에만 페이지 권한을 가져올 수 있다. 즉 그말은  서비스워커는 페이지 로딩이 끝난 뒤에는 페이지를 제어 할 수 없다. 
* 중복(Redundant)
  * 서비스워커가 등록중(중복)이거나 설치중에 실패하거나, 새로운 버전으로 교체된다면 **중복**상태가 된다. 
  * 이 상태에 있는 서비스워커는 앱에 아무런 영향을 끼치 못한다. 



### 왜 서비스워커가 앱의 CSS를 새로고침을 한 경우에만 바꿔줄까?

1. 사용자가 사이트에 처음 방문하면 앱은 서비스워커를 등록한다. 
2. install 이벤트로 설치를 진행하고 설치됨 상태로 들어서고 바로 활성화 중상태가 된다. 마지막으로 서비스워커는 활성화됨 상태로 들어가고 이제 페이지를 제어할 준비가 됐다.
3. 하지만 서비스워커가 설치되고 활성화되는 시간동안 이미 페이지는 로딩과 렌더링을 시작했다.
4. 서비스워커가 활성화 됐더라도 페이지를 제어할 수 없다. 
5. 페이지를 한번 새로고침해야 서비스워커가 활성화 되고 페이지도 제어할 수 있다.



#### (책 77페이지)서비스워커가 페이지로딩 후에 페이지를 제어할 수 없는 이유





## 서비스워커의 수명과 waitUntil의 중요성

서비스워커의 수명은 서비스워커가 처리하는 이벤트와 직접적인 연관이 있다. 

* 서비스워커 범위내에서 이벤트가 발생하면 서비스워커는 활성화되고 이벤트를 처리한 뒤 종료된다.
* 다시말해 사이트를 방문할 때 서비스워커가 시작되고 페이지에서 이벤트 처리를 완료하는 즉시 종료된다.
* 다른 이벤트가 나중에 들어오면 서비스워커는 다시 시작되고 이벤트처리를 완료하는 즉시 종료된다.

이러한 이유로 서비스워커가 자신의 이벤트를 끝내고 즉시 종료하는 것을 막기 위해 비동기작 호출을 사용한다.



## 서비스워커 업데이트 하기

아래의 코드는 배경을 빨간색으로 변경하는 코드이다. 

```javascript
self.addEventListener('fetch', function(event) {
    if (event.request.url.includes('bootstrap.min.css')) {
        event.respondWith(
            new Response('.hotel-slogan {background: red!important;} nav{display:none}', {
                headers: { 'Content-Type': 'text/css' }
            })
        );
    }
});
```

하지만 새로고침을 계속 해도 변하지 않는다.(많이 하면 변하긴 한다.)

개발자도구에서 Application에서 서비스워커 항목에서 보면 아래와 같다.

![2개의 서비스워커중 하나만 실행](..\참고자료\2개의 서비스워커중 하나만 실행.jpg)

두개(#94와 #95)의 서비스 워커가 등록되어 있지만 하나의 서비스워커가 페이지를 제어한다. 

* 서비스워커와 함께 페이지가 로딩되면 해당 페이지는 서비스워커 코드의 업데이트가 있는지 확인한다.
* 이후 변경사항이 있으면 새 서비스워커파일을 설치하고 등록한다. 
* 설치가 왼료되면 서비스워커는 바로 교체되는 것이 아닌 **대기중**상태에 남게된다.
* 윈도우창이  꺼지거나 서비스워커의 범위를 벗어난 페이지를 이동할 때까지 새로운 서비스워커는 대기 상태를 유지해야한다. 
* 이후 활성화 되어있던 서비스워커가 제어하던 페이지가 모두 꺼진 이후 새로운 서비스가 활성화되고 이전의 서비스워커는 **중복**상태가 된다



## 캐시를 관리해야 하는 이유

이전의 코드를 예로 들어 보자 아래와 같은 코드가 있을때 오프라인의 콘텐츠를 바꾸고자 한다. 

```javascript
//캐시의 버전을 바꾸어 보자
//var CACHE_NAME = "gih-cache";
var CACHE_NAME = "gih-cache-v2";
```

그러기위해 캐시의 버전을 v2로 설정하면 2가지의 묙표를 달성할 수 있다. 

1. 사소한 내용이라도 변경사항이 서비스워커 파일에 반영되면 브라우저는 활성화된 서비스워커를 새로운 서비스워커로 바꿔야 한다고 인지한다.그래서 새로운 install 이벤트를 발생시킨다.
2. 이 방법으로 하면 각 버전의 서비스워커에 해당하는 **별도의 캐시**를 생성한다.

별도의 캐시를 생성하는 것이 중요한 이유는 캐시가 이미 업데이트 되었더라도 사용자가 열려있는 페이지를 닫기 전까지는 기존 서비스워커가 활성화되어 있기 때문이다. 각각의 서비스워커는 각자의  캐시를 가지므로 예상치 못한 오류를 방지한다.



## 캐시관리 및 이전 캐시 제거

